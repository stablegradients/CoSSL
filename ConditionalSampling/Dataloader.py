import torch
import numpy as np
import utils
from torch.utils.data import Dataset
from collections import Counter
import matplotlib.pyplot as plt


class UnlabeledDataLoader():

    def __init__(self, ulb_dataset, model, head, sampling_dist, num_classes, batch_size):
        super(UnlabeledDataLoader, self).__init__()
        
        self.model = model
        self.head = head
        self.ulb_dataset = ulb_dataset
        self.sampling_dist = sampling_dist
        self.num_classes = num_classes
        self.batch_size = batch_size

        self.pseudo_labels = self.gen_pl()
        self.ulb_prior = self.get_ulb_prior()
        self.ulb_dataset.targets = self.pseudo_labels
        self.weights = self.get_weights()  # a list of list of p-l and corresponding weights
        self.loaders = self.get_loaders()
        self.ulb_dataset.targets = self.pseudo_labels
        
    
    def gen_pl(self):
        list_labels = []
        ulb_loader = torch.utils.data.DataLoader(self.ulb_dataset, batch_size= 128, num_workers=8, shuffle=False)
        self.model.eval()
        with torch.no_grad():
            for (inputs_u, inputs_u2, inputs_u3), gt_targets_u, idx_u in ulb_loader:
                _, _, feats = self.model(inputs_u.cuda(), return_feature=True)
                pred = self.head(feats.squeeze())
                pred = torch.argmax(pred, dim=1)
                list_labels.append(pred.cpu().numpy().flatten())

        pseudo_labels = np.concatenate(list_labels).ravel()
        return pseudo_labels.tolist()

    def get_ulb_prior(self):
        ulb_prior_ = [np.sum(np.array(self.pseudo_labels) == i) for i in range(self.num_classes)]
        ulb_prior = [x/sum(ulb_prior_) for x in ulb_prior_]
        print("ulb prior", ulb_prior)
        return ulb_prior


    def get_loaders(self):
        """
        Returns a dict of (num_classes) dataloaders of batch size 1 depending on the target distribution

        Args:
            num_classes (int): number of dataloaders (equal to number of classes in the dataset)
            pseudo_labels (list): list of pseudo-labels generated by the model
            target_dist (tensor): target distribution obtained by dM/dCij

        Returns:
            dict: dictionary of num_classes loaders
        """
        loader_dict = {}
        for i in range(self.num_classes):
            sampler = torch.utils.data.WeightedRandomSampler(weights=self.weights[i], num_samples = len(self.pseudo_labels), replacement = True)
            loader = torch.utils.data.DataLoader(self.ulb_dataset, batch_size=None, num_workers=8, sampler=sampler)
            loader_dict.update({f"{i}":iter(loader)})
        return loader_dict


    def get_weights(self):
        """Returns the sampling weights for each data instance in the dataset 

        Args:
            pseudo_labels (list): list of pseudo-labels generated by the model
            lbl (tensor): labels present in one batch obtained from the dataloader
            target_dist (tensor): target distribution obtained by dM/dCij

        Returns:
            list: list of instance-wise weights to be passed into the sampler
        """
        wts = []
        for plbl_target in range(self.num_classes):
            wts_class = []    
            for pl in self.pseudo_labels:
                wts_class.append(float(self.sampling_dist[plbl_target][pl]/self.ulb_prior[pl]))
            wts.append(wts_class)
        return wts

    def get_batch(self, labels):
        """Returns a batch of unlabeled images and their pseudo labels sampled from a distribution dependent 

        Args:
            labels (torch.tensor): labels obtained from one minibatch of the labeled loader

        Returns:
            img: torch.tensor of unlabeled images (shape NxCxHxW)
            lbl_ulb: torch tensor of sampled pseudo labels (shape Nx1) 
        """
        pl_list = []
        image_list = []
        
        for i in labels:
            image , sampled_label, idx = next(self.loaders[f'{i}'])
            # print(image)
            pl_list.append(self.pseudo_labels[idx]) 
            image_list.append(image[0])

        pl_list = torch.tensor(pl_list)
        image_list = torch.stack(image_list)
        return image_list, pl_list


if(__name__=="__main__"):
    print('work in progress')